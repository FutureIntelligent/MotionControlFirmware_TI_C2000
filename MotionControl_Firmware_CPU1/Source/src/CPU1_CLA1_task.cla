
#include "CPU1_CLA1_common.h"
#include "F28x_Project.h"

__interrupt void Cla1Task1 ( void )
{
  // count CLA execution time
  RESTART_CLOCK;

  Cla1SoftIntRegs.SOFTINTEN.bit.TASK1 = 1;

  AdcaRegs.ADCINTFLGCLR.bit.ADCINT1 = 1;
  sensorSampleA = AdcaResultRegs.ADCRESULT0;
  sensorSampleB = AdcbResultRegs.ADCRESULT0;
  CLA_SampleBufferA[CLA_SampleCounter] = sensorSampleA;
  CLA_SampleBufferB[CLA_SampleCounter++] = sensorSampleB;

  // switch case structure for static multi-tasking
  switch(CLA_CycleCounter){
    case 0:
      // execute current controller
      CL_Error_Ia = (float32_t)(CL_Setpoint_Ia - sensorSampleA);
      CL_Error_Ib = (float32_t)(CL_Setpoint_Ib - sensorSampleB);
      CL_Integral_Ia += CL_Ki * CL_Error_Ia;
      CL_Integral_Ib += CL_Ki * CL_Error_Ib;
      CL_Output_Ua = CL_Kp*CL_Error_Ia + CL_Integral_Ia;
      CL_Output_Ub = CL_Kp*CL_Error_Ib + CL_Integral_Ib;

      // output level limiting and anti-windup
      if(CL_Output_Ua > CL_OutputLimit){
        CL_Integral_Ia -= CL_Output_Ua - CL_OutputLimit;
        CL_Output_Ua = CL_OutputLimit;
      } else if(CL_Output_Ua < -CL_OutputLimit) {
        CL_Integral_Ia -= CL_Output_Ua + CL_OutputLimit;
        CL_Output_Ua = -CL_OutputLimit;
      }

      if(CL_Output_Ub > CL_OutputLimit){
        CL_Integral_Ib -= CL_Output_Ub - CL_OutputLimit;
        CL_Output_Ub = CL_OutputLimit;
      } else if(CL_Output_Ub < -CL_OutputLimit) {
        CL_Integral_Ib -= CL_Output_Ub + CL_OutputLimit;
        CL_Output_Ub = -CL_OutputLimit;
      }

      // output phase C chosen to make neutro point voltage zero
      CL_Output_Uc = -CL_Output_Ua -CL_Output_Ub;

      // PWM modulation
      if(CL_Output_Ua<CL_Output_Ub){
        if(CL_Output_Ua<CL_Output_Uc){
          CL_OutputOffset = -CL_Output_Ua;
        }
      }else if(CL_Output_Ub<CL_Output_Uc){
        CL_OutputOffset = -CL_Output_Ub;
      }else{
        CL_OutputOffset = -CL_Output_Uc;
      }

      CL_Output_Ua += CL_OutputOffset;
      CL_Output_Ub += CL_OutputOffset;
      CL_Output_Uc += CL_OutputOffset;

      break;
    case 1:
      sensorSampleA += 2;
      break;
    case 2:
      sensorSampleA += 10;
      break;
    case 3:
      sensorSampleA += 3;
      break;
    case 4:
      sensorSampleA += 4;
      break;
    case 5:
      sensorSampleA += 5;
      break;
    case 6:
      sensorSampleA += 6;
      break;
    case 7:
      sensorSampleA += 7;
      break;
    case 8:
      sensorSampleA += 8;
      break;
    case 9:
      sensorSampleA += 9;
      break;
    default:
      break;
  }

  if(CLA_SampleCounter==20){
    CLA_SampleCounter = 0;
  }

  if(CLA_CycleCounter==9){
    CLA_CycleCounter = 0;
    CLA_SampleBufferActiveHalf = (~CLA_SampleBufferActiveHalf) & 0x0001;
    //Cla1SoftIntRegs.SOFTINTFRC.bit.TASK1 = 1;
  } else {
    CLA_CycleCounter += 1;
  }

  READ_CLOCK(timeCounter);

  // put it here for debug purpose
  if(CLA_CycleCounter==1){
    Cla1SoftIntRegs.SOFTINTFRC.bit.TASK1 = 1;
  }
}

__interrupt void Cla1Task2 ( void )
{

}

__interrupt void Cla1Task3 ( void )
{

}

__interrupt void Cla1Task4 ( void )
{

}

__interrupt void Cla1Task5 ( void )
{

}

__interrupt void Cla1Task6 ( void )
{

}

/**
 *  task 7 is used to reset current controller
 */
__interrupt void Cla1Task7 ( void )
{
  CL_Integral_Ia = 0;
  CL_Integral_Ib = 0;
}

/**
 *  task 8 is used to initialize CLA variables
 */
__interrupt void Cla1Task8 ( void )
{
  CLA_SampleBufferActiveHalf = 1;
  CLA_SampleCounter = 0;
  CLA_CycleCounter = 0;


}
